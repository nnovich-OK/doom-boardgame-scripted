utils = {}
local package = utils

-- PACKAGE IMPORT
setmetatable(utils, {__index = _G})
local constants = require "constants"

-- PACKAGE BODY
local _ENV = package

-- Variables
local marines = {}
local guideGUID = ""

-- Local methods declaration
local isLarge

function getMarine(color)
  if #marines == 0 then
    for _,obj in ipairs(getAllObjects()) do
      if isMarine(obj) then
        local objColor = getColor(obj.getName())
        marines[objColor] = obj.getGUID()
      end
    end
  end
  return getObjectFromGUID(marines[color])
end

function getMarineCount()
  local count = 0
  for _, clr in ipairs(constants.allMarineColors) do
    if Player[clr].seated then
      count = count + 1
    end
  end

  return math.max(1, count)
end


function setTableDefaultValue(table, value)
  local key = {}
  local mt = getmetatable(table) or {}
  mt.__index = function(t) return t[key] end
  table[key] = value
  setmetatable(table, mt)
end

function isSingleFigurine(obj)
  -- Tag should be Figurine, but TTS apparently might set tag to Generic on first frame
  return (obj.tag == "Figurine" or obj.tag == "Generic") and obj.getQuantity() == -1
end

function isMonster(obj)
  if not isSingleFigurine(obj) then
    return false
  end

  local name = obj.getName()
  for i,v in ipairs(constants.mnstList) do
    if (string.find(name, v, 1, true)) then
      return true
    end
  end

  return false
end

function isMarine(obj)
  if not isSingleFigurine(obj) then
    return false
  end

  return (string.find(obj.getName(), "Marine", 1, true) ~= nil)
end

function isCharacter(obj)
  return isMonster(obj) or isMarine(obj)
end

function isDoor(obj)
  return obj.tag == "Generic" and string.find(obj.getName(), "Door") ~= nil
end

function isMapTile(obj)
  return obj.tag == "Generic" and string.find(obj.getName(), "Map") ~= nil
end

function isAmmoToken(obj)
  return obj.tag == "Card" and
    (string.find(obj.getName(), "Shells/Bullets") ~= nil
    or string.find(obj.getName(), "Rockets/Grenades") ~= nil
    or string.find(obj.getName(), "Energy Cell") ~= nil)
end

function isTeleporter(obj)
  return obj.tag == "Card" and string.find(obj.getName(), "Teleporter") ~= nil
end

function isObstacleToken(obj)
  return (obj.tag == "Card" or obj.tag == "Generic") and
    (string.find(obj.getName(), "Obstacle") ~= nil
    or string.find(obj.getName(), "Barrel") ~= nil
    or string.find(obj.getName(), "Duct") ~= nil)
end

function isCompassToken(obj)
  return obj.tag == "Card" and string.find(obj.getName(), "Compass") ~= nil
end

function isEncounterToken(obj)
  return (obj.tag == "Card" or obj.tag=="Generic") and string.find(obj.getName(), "Encounter") ~= nil
end

function isToken(obj)
  return (obj.tag == "Card" or obj.tag=="Generic") and constants.tokenList[obj.getName()]
end

function isDeckOfTokens(obj)
  if obj.tag ~= "Deck" or obj.getQuantity() == -1 then
    return false
  end

  for _, innerObj in ipairs(obj.getObjects()) do
    if not constants.tokenList[innerObj.name] then
      return false
    end
  end

  return true
end


-- recursion is internal parameter, shouldn't be used from outside
function getColor(str, recursion)
  for _, clr in ipairs(constants.allPlayerColors) do
    if string.find(str, clr, 1, true) then
      -- ensure it's the only color present in str
      if not recursion and getColor(string.gsub(str, clr, "", 1), true) then
        log(str, "ERROR getColor is used on string with two colors")
        return nil
      else
        return clr
      end
    end
  end

  return nil
end

function getActorLabel(color)
  return Player[color].steam_name or getMarine(color).getName()
end

-- should be applied to strings like "myXmlFieldRed" to remove "Red"
function stripXmlFieldColor(str)
  for _, clr in ipairs(constants.allPlayerColors) do
    if string.find(str, clr.."$") then
      return string.gsub(str, clr.."$", ""), clr
    end
  end
  return str
end


-- return true if figure is 2 or more spaces width in direction of X and Z
function isLarge(figure)
  local bounds = figure.getBounds()
  return {
    x = (bounds.size.x > 1.5),
    z = (bounds.size.z > 1.5)
  }
end

function getDistance(first, second)
  local roundingDelta = {x = 0.5, z = 0.5}

  local position = {first.getPosition(), second.getPosition()}

  for i, figure in ipairs({first, second}) do
    local isLargeFigure = isLarge(figure)
    if isLargeFigure.x then
      roundingDelta.x = roundingDelta.x - 0.5
    end

    if isLargeFigure.z then
      roundingDelta.z = roundingDelta.z - 0.5
    end

    if isLargeFigure.x ~= isLargeFigure.z then
      -- special handling for demon, since its position doesn't corresponsd to geometric center
      -- current position is center of head cell
      -- correct, so we use geometric center instead
      local angle = figure.getRotation().y * math.pi / 180
      position[i].x = position[i].x + 0.5 * math.cos(angle)
      position[i].z = position[i].z - 0.5 * math.sin(angle)
    end
  end

  local dx = math.floor(math.abs(position[2].x - position[1].x) + roundingDelta.x)
  local dz = math.floor(math.abs(position[2].z - position[1].z) + roundingDelta.z)

  return math.max(dx, dz)
end

function isAboveMap(obj)
  local castPosition = obj.getPosition()
  local large = isLarge(obj)
  if large.x and large.z then
    -- for large creatures cast from center of any square instead of center of full figurine
    -- this way even standing above connection of two pieces will still be reported as above map
    -- despite figurine center is directly above crack
    castPosition.x = castPosition.x + 0.5
    castPosition.z = castPosition.z + 0.5
  end
  local hitTable = Physics.cast(
    {origin=castPosition, direction={0,-1,0}, debug=false, max_distance=10})

  for _, hit in ipairs(hitTable) do
    if hit.hit_object.tag == "Generic"
      and string.find(hit.hit_object.getName(), "Map")
    then
      return true
    end
  end

  return false
end

function getMonsterType(fullName)
  for _, type in ipairs(constants.mnstList) do
    if string.find(fullName, type) then
      return type
    end
  end

  return nil
end

function getGuide()
  local guide = getObjectFromGUID(guideGUID)
  if guide then
    return guide
  end

  for _, obj in ipairs(getAllObjects()) do
    if obj.getName() == "Invader Player Guide" then
      guideGUID = obj.getGUID()
      return obj
    end
  end
end

return package
