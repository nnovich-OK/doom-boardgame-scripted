require("instances")
require("constants")

-- Local methods declaration
local walkDepth
local findSplit
local getSplitAppendixes
local performSplit
local findRename
local performRename
local deepcopy


--TODO delete
local function debugShowNode(xml, name)
  walkDepth(xml,
  function(xml, pos)   return xml
      and xml[pos]
      and xml[pos].attributes
      and xml[pos].attributes.id
      and string.find(xml[pos].attributes.id, name, 1, true)
  end,
  function(xml, pos) log(xml[pos]) end
  )
end


--[[
Searches for nodes with preproc attribute, then:
 - splitColor -> removes node, but inserts four deep copies of it, one for each player.
 Each copy has the same name as original appended with player color (e.g fieldNameBlue)
 All node children are also renamed the same way. Node visibility is set to player color.
 Preproc attribute is cleared.
 - splitColorKeepVisibility -> same as splitColor, but no changes to visibility
 - splitNumber<N> (e.g. splitNumber6) -> same as splitColor, but number of copies is N,
 name appendix is number from 1 to N
  - splitNumber0<N> (e.g. splitNumber06) -> same as above, but appendix is from 0 to N
]]
function preprocess()
  local xml = Global.UI.getXmlTable()
  walkDepth(xml, findSplit, performSplit)
  Global.UI.setXmlTable(xml)

  --debugShowNode(xml, "giveToRedItem")

  -- notify anyone interested
  Wait.frames(function()
      for _,v in ipairs({"inv", "luck"}) do
        instances[v].call("onPreprocFinished")
      end
    end, 1)
end

function walkDepth(xml, condition, action)
  if not xml then
    return false
  end

  local result = false
  for i,v in ipairs(xml) do
    -- always go for the children first
    -- this way nodes are processes from the max depth earlier
    local chlidRez = walkDepth(v.children, condition, action)
    result = result or chlidRez

    -- then work on the current node
    if condition(xml, i) then
      action(xml, i)
      result = true
    end

  end

  return result
end

function findSplit(xml, pos)
  return xml
    and xml[pos]
    and xml[pos].attributes
    and xml[pos].attributes.preproc
    and string.find(xml[pos].attributes.preproc, "split", 1, true)
end


function getSplitAppendixes(preprocString)
  if string.find(preprocString, "splitColor") then
    return constants.allPlayerColors
  elseif string.find(preprocString, "splitNumber") then
    local num = tonumber(string.match(preprocString, "%d+"), 10)
    local group = {}
    if string.find(preprocString, "splitNumber0") then
      -- start from zero
      table.insert(group, 0)
    end
    for i = 1, num do
      table.insert(group, i)
    end
    return group
  end
end

function performSplit(xml, pos)
  local node = xml[pos]
  --log(node, ">>> SPLIT HERE: ")
  table.remove(xml, pos)

  local splitGroup = getSplitAppendixes(node.attributes.preproc)
  local changeVisibility = (node.attributes.preproc == "splitColor")
  node.attributes.preproc = nil
  for i,appendix in ipairs(splitGroup) do
    -- make deep copy, so renaming newNode children doen't change original node
    local newNode = deepcopy(node)

    if changeVisibility then
      -- appendix is also a player color
      newNode.attributes.visibility = appendix
    end
    if newNode.attributes.id and newNode.attributes.id ~= "" then
      newNode.attributes.id = newNode.attributes.id .. appendix
    end

    walkDepth(
      newNode.children,
      findRename,
      function(xml, pos) performRename(xml, pos, appendix) end
    )
    table.insert(xml, pos + i - 1, newNode)
  end

  --log("<<< SPLIT RETURN\n")
end

function findRename(xml, pos)
  return xml
    and xml[pos]
    and xml[pos].attributes
    and xml[pos].attributes.id
end

function performRename(xml, pos, appendix)
  local node = xml[pos]
  node.attributes.id = (node.attributes.id or "") .. appendix
  --log(node, " -  NAMED HERE: ")
end


function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end