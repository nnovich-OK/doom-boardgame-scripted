redRotationValues = {
  {value="range=3 dmg=1",           rotation={x=0, y=0, z=0}},
  {value="range=0 dmg=4 ammo",      rotation={x=0, y=0, z=90}},
  {value="miss",                    rotation={x=0, y=0, z=180}},
  {value="range=2 dmg=2",           rotation={x=0, y=0, z=270}},
  {value="range=1 dmg=3 ammo",      rotation={x=90, y=0, z=0}},
  {value="range=1 dmg=3",           rotation={x=270, y=0, z=0}},
}

yellowRotationValues = {
  {value="range=3 dmg=1",           rotation={x=0, y=0, z=0}},
  {value="range=4 dmg=0 ammo",      rotation={x=0, y=0, z=90}},
  {value="miss",                    rotation={x=0, y=0, z=180}},
  {value="range=3 dmg=1 ammo",      rotation={x=0, y=0, z=270}},
  {value="range=1 dmg=3",           rotation={x=90, y=0, z=0}},
  {value="range=2 dmg=2",           rotation={x=270, y=0, z=0}},
}

greenRotationValues = {
  {value="range=1 dmg=1",           rotation={x=0, y=0, z=0}},
  {value="range=2 dmg=0",           rotation={x=0, y=0, z=90}},
  {value="range=3 dmg=0",           rotation={x=0, y=0, z=180}},
  {value="range=2 dmg=1",           rotation={x=0, y=0, z=270}},
  {value="range=3 dmg=0",           rotation={x=90, y=0, z=0}},
  {value="range=2 dmg=0",           rotation={x=270, y=0, z=0}},
}
blueRotationValues = {
  {value="range=1 dmg=1",           rotation={x=0, y=0, z=0}},
  {value="range=0 dmg=2",           rotation={x=0, y=0, z=90}},
  {value="range=0 dmg=3",           rotation={x=0, y=0, z=180}},
  {value="range=0 dmg=2",           rotation={x=0, y=0, z=270}},
  {value="range=0 dmg=3",           rotation={x=90, y=0, z=0}},
  {value="range=1 dmg=2",           rotation={x=270, y=0, z=0}},
}


-- weight for duplicated sides
redDie = {
  "miss",
  {range=0, dmg=4, weight=1},
  {range=1, dmg=3, weight=2},
  {range=2, dmg=2, weight=1},
  {range=3, dmg=1, weight=1},
}

yellowDie = {
  "miss",
  {range=1, dmg=3, weight=1},
  {range=2, dmg=2, weight=1},
  {range=3, dmg=1, weight=2},
  {range=4, dmg=0, weight=1},
}

greenDie = {
  {range=1, dmg=1, weight=1},
  {range=2, dmg=1, weight=1},
  {range=2, dmg=0, weight=2},
  {range=3, dmg=0, weight=2},
}

blueDie = {
  {range=0, dmg=3, weight=2},
  {range=0, dmg=2, weight=2},
  {range=1, dmg=2, weight=1},
  {range=1, dmg=1, weight=1},
}


-- will also store dieObj with reference to actual object
diceCollection = {
  red    = {state = {}, die = redDie, guid = "3e0276", rotVal = redRotationValues},
  yellow = {state = {}, die = yellowDie, guid = "d1aad4", rotVal = yellowRotationValues},
  green1 = {state = {}, die = greenDie, guid = "3e7c9c", rotVal = greenRotationValues},
  green2 = {state = {}, die = greenDie, guid = "c3ae7e", rotVal = greenRotationValues},
  blue1  = {state = {}, die = blueDie, guid = "6128fe", rotVal = blueRotationValues},
  blue2  = {state = {}, die = blueDie, guid = "bdba03", rotVal = blueRotationValues},
}


-- will store state and value for all dices of the last roll
lastRoll = {Red={}, Green={}, Blue={}, White={}}
reroll = {}
cumulativeStatsMode = {}


paramRange = {
   -- max hit distance is 15 plus accuracy bonus
  distance = { min = 0, max = 15 },

  -- max pure dmg is 15 plus deadly bonus
  -- max monster armor is 5
  -- I believe, 10 armor should be enough for everyone :)
  armor   = { min = 1, max = 10 },
  accuracy = { min = 0, max = 10 },
  deadly   = { min = 0, max = 10 },
}

-- individual parameters of calculator of each player
prm = {Red={}, Green={}, Blue={}, White={}}
-- damage prediction for each player
predictedStats = {Red={}, Green={}, Blue={}, White={}}

function onload()
  initParams()

  Wait.time(updateDiceFaces, 0.25, -1)
  Wait.time(bringDiceBack, 0.5, -1)
end


function initParams()
  for _,color in ipairs(Global.getTable("allPlayerColors")) do
    setDefaultParams(color)
  end

  -- Save reference to dice into collection
  -- also assign rotation values
  for k,v in pairs(diceCollection) do
    v.dieObj = getObjectFromGUID(v.guid)
    if v.dieObj == nil then
      print("Can't find dice " .. k)
    else
      v.dieObj.setLock(false)
      v.dieObj.highlightOff()
      v.dieObj.setRotationValues(v.rotVal)
    end
  end
end


function setDefaultParams(player_color, section)
  if not section or section == "" then
    section = "dice target bonus"
  end

  if string.find(section, "dice", 1, true) then
    for k in pairs(diceCollection) do
      setDice(player_color, k, false)
    end

    Global.UI.setAttribute("reroll", "isOn", "false")
    rerollToggle(Player[player_color], "False", "reroll")
  end

  if string.find(section, "target", 1, true) then
    setParam(player_color, "armor", paramRange.armor.min)
    setParam(player_color, "distance", paramRange.distance.min)
  end

  if string.find(section, "bonus", 1, true) then
    setParam(player_color, "accuracy", paramRange.accuracy.min)
    setParam(player_color, "deadly", paramRange.deadly.min)
  end
end


function clearCalc(player, value, id)
  setDefaultParams(player.color)

  for _,v in pairs(diceCollection) do
    v.dieObj.highlightOff()
  end
end


function setParam(player_color, name, value)
  prm[player_color][name] = value
  displayParam(player_color, name)
end


function displayParam(player_color, name)
  -- DISTANCE
  if name == "distance" then
    if prm[player_color][name] == 0 then
      Global.UI.setAttribute(name..player_color, "text", "melee")
      Global.UI.setAttribute(name..player_color, "color", "red")
    else
      Global.UI.setAttribute(name..player_color, "text", prm[player_color][name])
      Global.UI.setAttribute(name..player_color, "color", "white")
    end

  elseif name == "accuracy" then
    if prm[player_color][name] == 0 then
      Global.UI.setAttribute(name..player_color, "text", "-")
    elseif prm[player_color][name] <= 4 then  -- can't fit more
      local emojiStr = ""
      for i = 1,prm[player_color][name] do
        emojiStr = emojiStr .. "◎"
      end
      Global.UI.setAttribute(name..player_color, "text", emojiStr)
    else
      Global.UI.setAttribute(name..player_color, "text", prm[player_color][name])
    end

  elseif name == "deadly" then
    if prm[player_color][name] == 0 then
      Global.UI.setAttribute(name..player_color, "text", "-")
    elseif prm[player_color][name] <= 3 then -- can't fit more
      local emojiStr = ""
      for i = 1,prm[player_color][name] do
        emojiStr = emojiStr .. "☠"
      end
      Global.UI.setAttribute(name..player_color, "text", emojiStr)
    else
      Global.UI.setAttribute(name..player_color, "text", prm[player_color][name])
    end


  else
    Global.UI.setAttribute(name..player_color, "text", prm[player_color][name])
  end
end

function setDice(player_color, id, active)
  diceCollection[id].state[player_color] = active

  Global.UI.setAttribute(id.."Shade"..player_color, "active", tostring(not active))
end


function toggleDice(player, value, id)
  --log(id .. player.color .. "=" .. tostring(not diceCollection[id].state[player.color]))
  setDice(player.color, id, not diceCollection[id].state[player.color])
end

function getParamName(id)
  for k in pairs(paramRange) do
    if string.find(id, k, 1, true) then
      return k
    end
  end
end

function getParamChange(id)
  if string.find(id, "+", 1, true) then
    return 1;
  else
    return -1;
  end
end

function adjustParam(player, value, id)
  local name = getParamName(id)
  local delta = getParamChange(id)
  local min = paramRange[name].min
  local max = paramRange[name].max

  if delta < 0  and prm[player.color][name] > min then
    setParam(player.color, name, prm[player.color][name] - 1)
  elseif delta > 0 and prm[player.color][name] < max then
    setParam(player.color, name, prm[player.color][name] + 1)
  end

  --log(name .. player.color .. "=" .. prm[player.color][name])
end



function calculate(player, value, id)
  local dice = {}
  for _,v in pairs(diceCollection) do
    if v.state[player.color] then table.insert(dice, v.die) end
  end

  if dice[1] == nil then
    broadcastToColor("Choose at least one die", player.color, stringColorToRGB(player.color))
    return
  end

  broadcastToAll(player.steam_name .. " calculates...", stringColorToRGB(player.color))

  -- caclulate number of cases for each outcome
  local state = {range=0, dmg=0, weight=1}
  predictedStats[player.color] = {}
  calcIteration(dice, 1, state, prm[player.color], predictedStats[player.color])

  -- convert to percentage
  local totalCases = 6^#dice
  for k,v in pairs(predictedStats[player.color]) do
    predictedStats[player.color][k] = predictedStats[player.color][k] * 100 / totalCases
  end

  -- add ammo consumption statistics
  -- red and yellow dice has chance of 1/3 to spend ammo each
  local ammoDices = 0
  if diceCollection.red.state[player.color] then ammoDices = ammoDices + 1 end
  if diceCollection.yellow.state[player.color] then ammoDices = ammoDices + 1 end
  predictedStats[player.color]["ammo"] = (1 - (2/3)^ammoDices) * 100

  showStats(player.color)
end

-- caclulate number of cases for each outcome
function calcIteration(dice, depth, state, params, rez)
  -- if reached the bottom, save predictedStatss and exit
  if dice[depth] == nil then
    if params.distance > (state.range + params.accuracy) then
      rez["miss"] = (rez["miss"] or 0) + state.weight
    else
      local hit = math.floor((state.dmg + params.deadly) / params.armor)
      rez[hit] = (rez[hit] or 0) + state.weight
    end
    return
  end

  for i,v in ipairs(dice[depth]) do
    if v == "miss" then
      -- handle miss separately
      local diceLeft = #dice - depth
      local missWeight = state.weight * (6^diceLeft)
      rez["miss"] = (rez["miss"] or 0) + missWeight
    else
      -- go to the next depth
      local newState = {
        range = state.range + v.range,
        dmg = state.dmg + v.dmg,
        weight = state.weight * v.weight,
      }

      calcIteration(dice, depth+1, newState, params, rez)
    end
  end
end

function showStats(player_color)
  --common stats
  Global.UI.setAttribute("ammoPb" .. player_color, "percentage", predictedStats[player_color]["ammo"] or 0)
  Global.UI.setAttribute("missPb" .. player_color, "percentage", predictedStats[player_color]["miss"] or 0)

  --specific stats
  if not cumulativeStatsMode[player_color] then
    setExactStats(player_color)
  else
    setCumulativeStats(player_color)
  end

  Global.call("instances").vis.call("showInterface", {id="stats", color=player_color})
end


function setExactStats(player_color)
  for i = 0,15 do
    Global.UI.setAttribute(
      tostring(i) .. "t" .. player_color,
      "text",
      tostring(i) .. "dmg")
    Global.UI.setAttribute(
      tostring(i) .. "Pb" .. player_color,
      "percentage",
      predictedStats[player_color][i] or 0)
  end
end

function setCumulativeStats(player_color)
  local sum = 0
  -- even though there are only 15 bars to display, to get proper sum of chances we should
  -- iterate predictedStats[player.color] from maxdmg+maxdeadly or more
  -- TODO: redefine all magic numbers through named variables
  for i=25,0,-1 do
    sum = sum + (predictedStats[player_color][i] or 0)
    Global.UI.setAttribute(tostring(i) .. "Pb" .. player_color, "percentage", sum)
    Global.UI.setAttribute(tostring(i) .. "t" .. player_color, "text", "≥" .. tostring(i) .. "dmg")
  end
end

function toggleStatsMode(player, value, id)
  cumulativeStatsMode[player.color] = not cumulativeStatsMode[player.color]
  showStats(player.color)
end


function rollWatch(player_color)
  for k,v in pairs(diceCollection) do
    if v.state[player_color] and not v.dieObj.resting then
      return false
    end
  end
  return true
end

function addDieValue(sum, value)
  sum.range = sum.range + (value.range or 0)
  sum.dmg = sum.dmg + (value.dmg or 0)
  sum.ammo = sum.ammo or value.ammo
  sum.miss = sum.miss or value.miss
end

function rollEnd(player_color)
  -- print each dice individually and count sum
  log(" --- Roll end --- ")

  local currentRoll = {}
  local sum = {range=0, dmg=0, ammo=false, miss=false}
  for k,v in pairs(diceCollection) do
    if v.state[player_color] then
      local value = getRotationValueTable(v.dieObj)
      log(value, k .." rolled by " .. player_color .. ": ")
      addDieValue(sum, value)
      currentRoll[k] = value
    else
      currentRoll[k] = nil
      if reroll[player_color] and lastRoll[player_color][k] then
        -- die wasn't rolled now, but it's part of previous roll, which is rerolled
        addDieValue(sum, lastRoll[player_color][k])
        log(lastRoll[player_color][k], k .. " used from previous roll: " )

        -- notify if displayed value and stored one are different
        local oldValueString = rotationValueTableToString(lastRoll[player_color][k])
        if v.dieObj.getRotationValue() ~= oldValueString then
          broadcastToAll("Note: " .. k .. " isn't rerolled, but it has been moved since last roll. " ..
          "Using " .. oldValueString .. " from last roll.",
          Color.Orange)
        end
      end
    end
  end

  if not reroll[player_color] then
    lastRoll[player_color] = currentRoll
  end

  -- raw sum report
  local total = ""
  if sum.miss then
    total = total .. "MISS "
  end
  total = total .. tostring(sum.range) .. "range"
  if prm[player_color].accuracy ~= 0 then
    total = total .. "+" .. tostring(prm[player_color].accuracy)
  end

  total = total .. " " .. tostring(sum.dmg) .. "dmg"
  if prm[player_color].deadly ~= 0 then
    total = total .. "+" .. tostring(prm[player_color].deadly)
  end

  if sum.ammo then total = total .. " ammo" end
  broadcastToAll(total, stringColorToRGB(player_color))

  -- bonus/armor/distance accounted
  if sum.miss then
    broadcastToAll("MISS on dice", Color.Pink)
  else
    if sum.range + prm[player_color].accuracy < prm[player_color].distance then
      broadcastToAll("MISS: Range + accuracy is too low", Color.Pink)
    else
      local hit = math.floor((sum.dmg + prm[player_color].deadly) / prm[player_color].armor)
      if hit == 0 then
        broadcastToAll("HIT: no penetration", Color.Pink)
      else
        broadcastToAll("HIT: " .. hit .. " wounds", Color.Pink)
      end
    end
  end

  -- highlight ammo consumption in CAPS if not melee and not invader player
  if sum.ammo and player_color ~= "White" and prm[player_color].distance ~= 0 then
    broadcastToAll("AMMO LOST", Color.Pink)
  end

  updateDiceFaces()

  -- This MUST be called, and also this should be the last thing to execute
  toggleInteraction(player_color, true)
end

function rollDice(player, value, id)
  local rollHappened = false
  for _,v in pairs(diceCollection) do
    if v.state[player.color] then
      v.dieObj.roll()
      v.dieObj.highlightOn(Color.pink, 45)
      rollHappened = true
    else
      v.dieObj.highlightOff()
    end
  end

  if not rollHappened then return end
  --shut down controls, so nobody messes with parameters
  toggleInteraction(player.color, false)

  local actionStr = " rolls..."
  if reroll[player.color] then
    actionStr = " rerolls..."
  end
  broadcastToAll(player.steam_name .. actionStr, stringColorToRGB(player.color))

  Wait.condition(
    function() return rollEnd(player.color) end,
    function() return rollWatch(player.color) end
  )
end

function rotationValueTableToString(value)
  if value.miss then
    return "miss"
  end

  local str = "range=" .. value.range .. " dmg=" .. value.dmg
  if value.ammo then
    return str .. " ammo"
  else
    return str
  end
end

function getRotationValueTable(obj)
  local str = obj.getRotationValue()
  local rez = {}
  for k, v in string.gmatch(str, "(%w+)=?(%w*)") do
    if v == nil or v == "" then
      rez[k] = true
    else
      rez[k] = v
    end
  end
  return rez
end

function toggleInteraction(player_color, active)
  rollOngoing = not active
  Global.UI.setAttribute("distance-", "interactable", active)
  Global.UI.setAttribute("distance+", "interactable", active)

  Global.UI.setAttribute("armor-", "interactable", active)
  Global.UI.setAttribute("armor+", "interactable", active)

  Global.UI.setAttribute("accuracy-", "interactable", active)
  Global.UI.setAttribute("accuracy+", "interactable", active)

  Global.UI.setAttribute("deadly-", "interactable", active)
  Global.UI.setAttribute("deadly+", "interactable", active)

  Global.UI.setAttribute("red", "interactable", active)
  Global.UI.setAttribute("yellow", "interactable", active)
  Global.UI.setAttribute("green1", "interactable", active)
  Global.UI.setAttribute("green2", "interactable", active)
  Global.UI.setAttribute("blue1", "interactable", active)
  Global.UI.setAttribute("blue2", "interactable", active)

  Global.UI.setAttribute("rollDice", "interactable", active)
  Global.UI.setAttribute("rollDice", "textColor", "white")

  Global.UI.setAttribute("clearPrm", "interactable", active)
  Global.UI.setAttribute("clearPrm", "textColor", "white")

  Global.UI.setAttribute("reroll", "interactable", active)
end


function updateDiceFaces()
  for k,v in pairs(diceCollection) do
    local clr = string.match(k, "(%a+)%d*")
    Global.UI.setAttribute(k.."Image", "image", clr .. " " .. v.dieObj.getRotationValue())
  end
end

function bringDiceBack()
  for k,v in pairs(diceCollection) do
    if v.dieObj.getPosition().y < -5 then
      broadcastToAll(k .. " die dropped off the table, returning...", Color.Pink)
      v.dieObj.setPosition({-8.50, 13.00, 34.00})
      v.dieObj.setVelocity({0, 0, 0})
    end
  end
end



function rerollToggle(player, value, id)
  reroll[player.color] = (value == "True")
  --log(id .. player.color .. "=" .. tostring(reroll[player.color]))

  if reroll[player.color] then
    for k in pairs(diceCollection) do
      if not lastRoll[player.color][k] then
        Global.call("instances").vis.call("hideInterface", {id=k, color=player.color})
        --Global.UI.setAttribute(k, "active", "false")
        setDice(player.color, k, false)
      end
    end
  else
    for k in pairs(diceCollection) do
      Global.call("instances").vis.call("showInterface", {id=k, color=player.color})
    end
  end
end

function configure(params)
  log(params, "Params: ")
  if not params or not params.color then
    log(params, "ERROR configure param missing color: ")
    return
  end

  if params.dice then
    setDefaultParams(params.color, "dice")
    for i,v in ipairs(params.dice) do
      setDice(params.color, v, true)
    end
  end

  if params.target then
    setDefaultParams(params.color, "target")
    for k,v in pairs(params.target) do
      setParam(params.color, k, v)
    end
  end

  if params.bonus then
    setDefaultParams(params.color, "bonus")
    if params.bonus ~= "none" then
      for k,v in pairs(params.bonus) do
        setParam(params.color, k, v)
      end
    end
  end

  Global.call("instances").vis.call("showInterface", {id="calculator", color=params.color})
end

function toggleCalc(player, value, id)
  Global.call("instances").vis.call("toggleInterface", {id="calculator", color=player.color})
end

function closeStats(player, value, id)
  Global.call("instances").vis.call("hideInterface", {id="stats", color=player.color})
end