local fragsScored = 0
local fragLimit = 6

local fragTintColors = {
  ["Red died"]="rgba(1, 0.6, 0.6, 1)",
  ["Green died"]="rgba(0.6, 1, 0.6, 1)",
  ["Blue died"]="rgba(0.6 0.6, 1, 1)",
}

local invMode = {Red={}, Green={}, Blue={}, White={}}
local lastInvMode = {Red={}, Green={}, Blue={}, White={}}

local pickableTokens = {
  ['Armor']='armor',

  ['Shells/Bullets']='shell',
  ['Rockets/Grenades']='rocket',
  ['Energy Cell']='cell',

  ['Chainsaw']='chainsaw',
  ['Shotgun']='shotgun',
  ['Machine Gun']='machinegun',
  ['Chain Gun']='chaingun',
  ['Rocket Launcher']='launcher',
  ['Plasma Gun']='plasma',
  ['BFG']='bfg',

  ['Berserk']='berserk',
  ['Adrenaline']='adrenalin',

  ['Blue Key']='bluekey',
  ['Yellow Key']='yellowkey',
  ['Red Key']='redkey',

  ['Health']='health',
}

local obtainableItems = {
  armor=true,
  shell=true,
  rocket=true,
  cell=true,
  chainsaw=true,
  machinegun=true,
  shotgun=true,
  chaingun=true,
  launcher=true,
  plasma=true,
  bfg=true,
  berserk=true,
  adrenalin=true,
  cancel=true,
  bluekey=true,
  yellowkey=true,
  redkey=true,
}

local transferableItems = {
  shell = true,
  rocket = true,
  cell = true,
  chainsaw = true,
  machinegun = true,
  shotgun = true,
  chaingun = true,
  launcher = true,
  plasma = true,
  bfg = true,
}

local sharedItems = {
  bluekey = true,
  yellowkey = true,
  redkey = true,
}

local itemLimit = {
  bluekey = 1,
  yellowkey = 1,
  redkey = 1,
  berserk = 3, -- seems like picking the new one just refreshes the duration
}

local countActivationThreshold = {
  fist = 2,
  chainsaw = 2,
  pistol = 2,
  machinegun = 2,
  shotgun = 2,
  chaingun = 2,
  grenade = 2,
  launcher = 2,
  plasma = 2,
  bfg = 2,

  bluekey = 2,
  yellowkey = 2,
  redkey = 2,
}

gunStats = {
  fist = {
    ammo = "",
    attack = {"red"},
    melee = true,
    attackMod = {},
    reminder = "",
  },

  chainsaw = {
    ammo = "",
    attack = {"red"},
    melee = true,
    attackMod = {deadly=1},
    reminder = "sweep",
  },

  pistol = {
    ammo = "shell",
    attack = {"yellow", "green2"},
    melee = false,
    attackMod = {},
    reminder = "",
  },

  machinegun = {
    ammo = "shell",
    attack = {"yellow", "blue2", "green2"},
    melee = false,
    attackMod = {accuracy=2},
    reminder = "",
  },

  shotgun = {
    ammo = "shell",
    attack = {"red", "blue1"},
    melee = false,
    attackMod = {deadly=1},
    reminder = "blow-through",
  },

  chaingun = {
    ammo = "shell",
    attack = {"red", "green1", "green2"},
    melee = false,
    attackMod = {accuracy=1},
    reminder = "blow-through",
  },

  grenade = {
    ammo = "rocket",
    attack = {"yellow", "blue1", "blue2"},
    melee = false,
    attackMod = {},
    reminder = "seeking, blast 1",
  },

  launcher = {
    ammo = "rocket",
    attack = {"yellow", "blue2", "green1", "green2"},
    melee = false,
    attackMod = {},
    reminder = "blast 1, knockback",
  },

  plasma = {
    ammo = "cell",
    attack = {"red", "yellow", "blue1", "green1"},
    melee = false,
    attackMod = {accuracy=1},
    reminder = "",
  },

  bfg = {
    ammo = "cell",
    attack = {"red", "yellow", "blue1", "green1", "blue2", "green2"},
    melee = false,
    attackMod = {deadly=1},
    reminder = "blast 2",
  },

}

-- Local methods declaration
local prepareGunAttack
local clearInvMode
local setInvMode
local getItemCount
local adjustItemCount

function onPreprocFinished()
  Global.UI.setAttribute("inventoryPanel" .. "Red", "color", "rgba(0.14, 0, 0, 0.95)")
  Global.UI.setAttribute("inventoryPanel" .. "Green", "color", "rgba(0, 0.1, 0, 0.95)")
  Global.UI.setAttribute("inventoryPanel" .. "Blue", "color", "rgba(0, 0, 0.1, 0.95)")

  Global.UI.setAttribute("giveToRedItemRed", "active", "false")
  Global.UI.setAttribute("giveToGreenItemGreen", "active", "false")
  Global.UI.setAttribute("giveToBlueItemBlue", "active", "false")
end

function showFrags(player, value, id)
  Global.call("instances").vis.call(
    "toggleInterface", {id="fragsPanel", color=player.color})
end

function updateFrag(player, value, id)
  if Global.call("instances").click.call("isDoubleClick",
    {color = player.color, id = id})
  then
    if player.color ~= "White" then
      broadcastToColor("Only white player can change frags",
        player.color,
        stringColorToRGB(player.color))
      return
    end

    local buttonNumber = string.match(id, "(%d+)")
    buttonNumber = tonumber(buttonNumber, 10)
    if buttonNumber > fragsScored then
      -- inactive button is hit, add new frag
      addFrag("manual")
    else
      -- active button is hit, remove frag
      -- it's the only way to remove frag
      Global.UI.setAttribute("fragImage" .. fragsScored, "color", "rgba(0.4, 0.4, 0.4, 1)")
      Global.UI.setAttribute("frag" .. fragsScored, "tooltip", "Double click to add")
      fragsScored = fragsScored-1
      broadcastToAll("Frag manually removed! Total: " .. fragsScored, Color.Orange)
    end
  end
end

-- source must be "manual", "<Color> died" or "full deck"
function addFrag(source)
  if (fragsScored >= fragLimit) then
    broadcastToAll("Can't add more frags! Already " .. fragLimit, Color.Orange)
  end

  fragsScored = fragsScored + 1

  Global.UI.setAttribute(
    "fragImage" .. fragsScored,
    "color",
    fragTintColors[source] or "White")
  Global.UI.setAttribute("frag" .. fragsScored, "tooltip", "Double click to remove")
  broadcastToAll("New frag (" .. source .. ")! Total: " .. fragsScored, Color.Orange)

  Global.call("instances").vis.call(
    "showInterface",
    {id="fragsPanel", color="White|Red|Green|Blue"})

end

function onInventoryItemClick(player, value, id)
  local item, itemColor = Global.call(
    "stripXmlFieldColor",
    (string.gsub(id, "InvButton", "")))


  --TODO check check berserk, check availability and not for white
  -- Set attack parameters
  if not invMode[player.color].action and gunStats[item] then
    prepareGunAttack(player.color, item)

  elseif invMode[player.color].action == "gainItem" then
    if obtainableItems[item] then
      printToAll(Global.call("getActorLabel", itemColor) .. " gained " .. item, player.color)
      adjustItemCount(itemColor, item, 1)
    else
      broadcastToColor("Can't gain " .. item, player.color, player.color)
    end

  elseif invMode[player.color].action == "loseItem" then
    if obtainableItems[item] then
      printToAll(Global.call("getActorLabel", itemColor) .. " lost " .. item, player.color)
      adjustItemCount(itemColor, item, -1)
    else
      broadcastToColor("Can't lose " .. item, player.color, player.color)
    end

  elseif string.find(invMode[player.color].action or "", "giveTo") then
    transferItem(player.color, itemColor, Global.call("getColor", invMode[player.color].action), item)
  end

  if not invMode[player.color].sticky then
    clearInvMode(player.color)
  end
end

function prepareGunAttack(player_color, item)
  if player_color ~= "White" then
    printToColor(player_color.." Marine uses " .. item .. " on... <target via Num1>",
      player_color,
      Color.Grey)
  else
    printToColor("Marine uses " .. item,
      player_color,
      Color.Grey)
  end

  if gunStats[item].reminder and gunStats[item].reminder ~= "" then
    printToColor("Reminder: " .. gunStats[item].reminder, player_color, Color.Grey)
  end

  local params = {
    color = player_color,
    dice  = gunStats[item].attack,
    bonus = gunStats[item].attackMod or "none",}

  Global.call("instances").calc.call("configure", params)
end

function showInventory(player, value, id)
  clearInvMode(player.color)
  Global.call("instances").vis.call("toggleInterface", {id="inventoryPanel"..value, color=player.color})
end

function onModeControlClick(player, value, id)
  if Global.call("instances").click.call("isDoubleClick",
    {color = player.color, id = id})
  then
    setInvMode(player.color, lastInvMode[player.color].action,  true)
  else
    local curMode = invMode[player.color].action
    local newMode = Global.call("stripXmlFieldColor", id)

    -- Don't enter give mode in case marines aren't adjacent
    if string.find(newMode, "giveTo") then
      local marineColor = (player.color == "White")
        and Global.call("instances").vis.call("getActiveInventoryForWhite")
        or player.color
      local givingMarine = Global.call("getMarine", marineColor)
      local takingMarine = Global.call("getMarine", Global.call("getColor", newMode))
      local dist = Global.call("getDistance", {from = givingMarine, to = takingMarine})
      if dist ~= 1 then
        broadcastToColor(takingMarine.getName() .. " must be on adjacent space", player.color, player.color)
        Global.call("instances").click.call("markAsSingleClick", {color = player.color, id = id})
        return
      end
    end

    clearInvMode(player.color)
    if curMode ~= newMode then
      setInvMode(player.color, newMode,  false)
    end
  end
end

function clearInvMode(player_color)
  if invMode[player_color].action then
    local textColor = Global.call("getColor", invMode[player_color].action) or "White"
    Global.UI.setAttribute(invMode[player_color].action .. player_color, "color", "rgba(0, 0, 0, 0.95)")
    Global.UI.setAttribute(invMode[player_color].action .. player_color, "textColor", textColor)
    invMode[player_color].action = nil
  end
  invMode[player_color].sticky = nil
end

function setInvMode(player_color, action, sticky)
  if not action then -- empty action should be set with clear
    return
  end

  invMode[player_color].action = action
  invMode[player_color].sticky = sticky
  lastInvMode[player_color].action = action
  if not sticky then
    Global.UI.setAttribute(invMode[player_color].action .. player_color, "color", "yellow")
  else
    Global.UI.setAttribute(invMode[player_color].action .. player_color, "color", "orange")
  end

end


function onAutopickClick(player, value, id)
  local marineColor = (player.color ~= "White") and player.color
    or Global.call("instances").vis.call("getActiveInventoryForWhite")

  local marine = Global.call("getMarine", marineColor)
  local hitTable = Physics.cast(
    {origin=marine.getPosition(), direction={0,-1,0}, debug=false, max_distance=0.5})

  local pickWorked = false
  for _, hit in ipairs(hitTable) do
    local item = pickableTokens[hit.hit_object.getName()]
    if hit.hit_object.tag == "Card" and item then

      local picked = true
      local amount = 1
      if item == "health" then
        amount = 0 -- no item is stored, health is applied immediately
        picked = marine.call("onHealthPickup", marineColor)
      elseif item == "berserk" then
        amount = 3
      end

      if picked then
        adjustItemCount(marineColor, item, amount)
        printToAll(marine.getName() .. " picked " .. item, player.color)
        hit.hit_object.destruct()
      end

      pickWorked = pickWorked or picked
    end
  end

  if not pickWorked then
    broadcastToColor("No pickable items under " .. marine.getName() .. " figurine",
      player.color,
      player.color)
  end
end

-- all colors can be different: white player forcing blue marine to share with red one
function transferItem(player_color, givingColor, takingColor, item)
  if not transferableItems[item] then
    broadcastToColor("Can't transfer " .. item, player_color, player_color)
    return
  end

  if adjustItemCount(givingColor, item, -1) == -1 then
    adjustItemCount(takingColor, item, 1)
    broadcastToAll(Global.call("getActorLabel", givingColor) .. " transfered " .. item .. " to " .. Global.call("getActorLabel", takingColor), player_color)
  else
    broadcastToColor("Can't transfer " .. item .. " since none is owned",
      player_color,
      player_color)
  end
end

function getItemCount(player_color, item)
  return tonumber(Global.UI.getAttribute(item.."InvText"..player_color, "text"), 10)
end

-- returns actual change in item count
function adjustItemCount(player_color, item, diff)
  if diff == 0 then
     return 0
  end

  local originalCount = getItemCount(player_color, item)
  local count = originalCount
  count = count + diff
  if count < 0 then
    count = 0
  end

  if item == "armor" and count < 1 then
    count = 1
  end

  local changedItemColors = {player_color}
  if sharedItems[item] then
    changedItemColors = Global.getTable("allMarineColors")
  end

  if itemLimit[item] and count > itemLimit[item] then
    count = itemLimit[item]
  end

  for _, clr in ipairs(changedItemColors) do
    Global.UI.setAttribute(item.."InvText"..clr, "text", count)

    if count >= (countActivationThreshold[item] or 1) then
      Global.UI.setAttribute(item.."InvText"..clr, "active", "true")
    else
      Global.UI.setAttribute(item.."InvText"..clr, "active", "false")
    end

    if count >= 1 then
      Global.UI.setAttribute(item.."InvImage"..clr, "color", "White")
    else
      Global.UI.setAttribute(item.."InvImage"..clr, "color", "rgba(0.4, 0.4, 0.4, 1)")
    end
  end

  return count - originalCount
end

function onPlayerTurnEnd(player_color_end, player_color_next)
 -- TODO: test
 -- when enabling turn system, first event contains neither nil nor "",
 -- but still doesn't have any valid number
  if player_color_end and string.find(player_color_end, "%a") then
    adjustItemCount(player_color_end, "berserk", -1)
  end
end