#include Console/console++

shown = {
  calculator = false,
  stats = false
}

cumulativeStatsMode = false

redRotationValues = {
  {value="range=3 dmg=1",           rotation={x=0, y=0, z=0}},
  {value="range=0 dmg=4 ammo",      rotation={x=0, y=0, z=90}},
  {value="miss",                    rotation={x=0, y=0, z=180}},
  {value="range=2 dmg=2",           rotation={x=0, y=0, z=270}},
  {value="range=1 dmg=3 ammo",      rotation={x=90, y=0, z=0}},
  {value="range=1 dmg=3",           rotation={x=270, y=0, z=0}},
}

yellowRotationValues = {
  {value="range=3 dmg=1",           rotation={x=0, y=0, z=0}},
  {value="range=4 dmg=0 ammo",      rotation={x=0, y=0, z=90}},
  {value="miss",                    rotation={x=0, y=0, z=180}},
  {value="range=3 dmg=1 ammo",      rotation={x=0, y=0, z=270}},
  {value="range=1 dmg=3",           rotation={x=90, y=0, z=0}},
  {value="range=2 dmg=2",           rotation={x=270, y=0, z=0}},
}

greenRotationValues = {
  {value="range=1 dmg=1",           rotation={x=0, y=0, z=0}},
  {value="range=2 dmg=0",           rotation={x=0, y=0, z=90}},
  {value="range=3 dmg=0",           rotation={x=0, y=0, z=180}},
  {value="range=2 dmg=1",           rotation={x=0, y=0, z=270}},
  {value="range=3 dmg=0",           rotation={x=90, y=0, z=0}},
  {value="range=2 dmg=0",           rotation={x=270, y=0, z=0}},
}
blueRotationValues = {
  {value="range=1 dmg=1",           rotation={x=0, y=0, z=0}},
  {value="range=0 dmg=2",           rotation={x=0, y=0, z=90}},
  {value="range=0 dmg=3",           rotation={x=0, y=0, z=180}},
  {value="range=0 dmg=2",           rotation={x=0, y=0, z=270}},
  {value="range=0 dmg=3",           rotation={x=90, y=0, z=0}},
  {value="range=1 dmg=2",           rotation={x=270, y=0, z=0}},
}

-- weight for duplicated sides
redDie = {
  "miss",
  {range=0, dmg=4, weight=1},
  {range=1, dmg=3, weight=2},
  {range=2, dmg=2, weight=1},
  {range=3, dmg=1, weight=1},
}

yellowDie = {
  "miss",
  {range=1, dmg=3, weight=1},
  {range=2, dmg=2, weight=1},
  {range=3, dmg=1, weight=2},
  {range=4, dmg=0, weight=1},
}

greenDie = {
  {range=1, dmg=1, weight=1},
  {range=2, dmg=1, weight=1},
  {range=2, dmg=0, weight=2},
  {range=3, dmg=0, weight=2},
}

blueDie = {
  {range=0, dmg=3, weight=2},
  {range=0, dmg=2, weight=2},
  {range=1, dmg=2, weight=1},
  {range=1, dmg=1, weight=1},
}

-- will also store dieObj with reference to actual object
diceCollection = {
  red    = {state = false, die = redDie, guid = "3e0276", rotVal = redRotationValues},
  yellow = {state = false, die = yellowDie, guid = "d1aad4", rotVal = yellowRotationValues},
  green1 = {state = false, die = greenDie, guid = "3e7c9c", rotVal = greenRotationValues},
  green2 = {state = false, die = greenDie, guid = "c3ae7e", rotVal = greenRotationValues},
  blue1  = {state = false, die = blueDie, guid = "6128fe", rotVal = blueRotationValues},
  blue2  = {state = false, die = blueDie, guid = "bdba03", rotVal = blueRotationValues},
}

-- will store state and value for all dices of the last roll
lastRoll = {}
reroll = false


paramRange = {
   -- max hit distance is 15 plus accuracy bonus
  distance = { min = 0, max = 15 },

  -- max pure dmg is 15 plus deadly bonus
  -- max monster armor is 5
  -- I believe, 10 armor should be enough for everyone :)
  armor   = { min = 1, max = 10 },
  accuracy = { min = 0, max = 10 },
  deadly   = { min = 0, max = 10 },
}

marines = {}
attackingChar = {}

mnstStats = {
  Zombie     = {speed=3, armor=2, health=2,
                attack = {"red", "blue1"},
                attackMod = {melee=true},
                reminder = "",
              },

  Trite      = {speed=5, armor=1, health=1,
                attack = {"red", "green1"},
                attackMod = {melee=true},
                reminder = "scuttle",
              },

  Imp        = {speed=4, armor=2, health=1,
                attack = {"yellow", "blue2"},
                attackMod = {accuracy=1},
                reminder = "",
              },

  Demon      = {speed=4, armor=3, health=2,
                attack = {"red", "blue1", "blue2"},
                attackMod = {melee=true},
                reminder = "watchful",
              },

  Mancubus   = {speed=2, armor=3, health=3,
                attack = {"yellow", "green2" ,"blue2"},
                attackMod = {deadly=1},
                reminder = "blow-through",
              },

  Archvile   = {speed=4, armor=3, health=2,
                attack = {"yellow", "green1", "green2" ,"blue2"},
                attackMod = {accuracy=4},
                reminder = "aimed",
            },

  Hellknight = {speed=3, armor=4, health=3,
                attack = {"red", "blue1", "blue2"},
                attackMod = {melee=true},
                reminder = "sweep, knockback",
              },

  Cyberdemon = {speed=4, armor=5, health=4,
                attack = {"red", "yellow", "green1", "green2", "blue1", "blue2"},
                attackMod = {},
                reminder = "aimed",
              },
}

function onload()
  initParams()

  Wait.time(updateDiceFaces, 0.25, -1)
  Wait.time(bringDiceBack, 0.5, -1)

  -- assets sometimes load later than they are needed by objects
  -- so blank squares are shown instead of images for armor, speed etc
  -- workaround - refresh XML to redraw interfaces
  refreshObjectUI()
end


function initParams()
  setDefaultParams()

  -- Save reference to dice into collection
  -- also assign rotation values
  for k,v in pairs(diceCollection) do
    v.dieObj = getObjectFromGUID(v.guid)
    if v.dieObj == nil then
      print("Can't find dice " .. k)
    else
      v.dieObj.setLock(false)
      v.dieObj.highlightOff()
      v.dieObj.setRotationValues(v.rotVal)
    end
  end

  for _,obj in ipairs(getAllObjects()) do
    if obj.getName() == "Red Marine" then
      marines.red = obj.getGUID()
    elseif obj.getName() == "Green Marine" then
      marines.green = obj.getGUID()
    elseif obj.getName() == "Blue Marine" then
       marines.blue = obj.getGUID()
    end
  end
end


function setDefaultParams()
    -- Set params to default (min) value
  prm = {}
  for k,v in pairs(paramRange) do
    setParam(k, v.min)
  end

  for k in pairs(diceCollection) do
    setDice(k, false)
  end

  Global.UI.setAttribute("reroll", "isOn", "false")
  rerollToggle(nil, "False", "reroll")
end

function clearCalc()
  setDefaultParams()

  for _,v in pairs(diceCollection) do
    v.dieObj.highlightOff()
  end
end

function setParam(name, value)
  prm[name] = value
  displayParam(name)
end


function displayParam(name)
  -- DISTANCE
  if name == "distance" then
    if prm[name] == 0 then
      Global.UI.setAttribute(name, "text", "melee")
      Global.UI.setAttribute(name, "color", "red")
    else
      Global.UI.setAttribute(name, "text", prm[name])
      Global.UI.setAttribute(name, "color", "white")
    end

  elseif name == "accuracy" then
    if prm[name] == 0 then
      Global.UI.setAttribute(name, "text", "-")
    elseif prm[name] <= 4 then  -- can't fit more
      local emojiStr = ""
      for i = 1,prm[name] do
        emojiStr = emojiStr .. "◎"
      end
      Global.UI.setAttribute(name, "text", emojiStr)
    else
      Global.UI.setAttribute(name, "text", prm[name])
    end

  elseif name == "deadly" then
    if prm[name] == 0 then
      Global.UI.setAttribute(name, "text", "-")
    elseif prm[name] <= 3 then -- can't fit more
      local emojiStr = ""
      for i = 1,prm[name] do
        emojiStr = emojiStr .. "☠"
      end
      Global.UI.setAttribute(name, "text", emojiStr)
    else
      Global.UI.setAttribute(name, "text", prm[name])
    end


  else
    Global.UI.setAttribute(name, "text", prm[name])
  end
end

function setDice(id, active)
  diceCollection[id].state = active

  if active then
    Global.UI.setAttribute(id.."Text", "text", "") --"✓"
    Global.UI.setAttribute(id.."Image", "color", "rgb(1,1,1)")
  else
    Global.UI.setAttribute(id.."Text", "text", "X")
    Global.UI.setAttribute(id.."Image", "color", "rgb(0.5,0.5,0.5)")
  end

  Global.UI.setAttribute(id, "isOn", tostring(not active))
end


function onPlayerConnect(player)
  -- assets sometimes load later than they are needed by objects
  -- so blank squares are shown instead of images for armor, speed etc
  -- workaround - refresh UI for all objects
  -- needed to be done for each player individually
  refreshObjectUI()
end

--[[ The Update function. This is called once per frame. --]]
function update ()
end

function showCalc()
  if shown.calculator == false then
     Global.UI.show("calculator")
     shown.calculator = true
     Global.UI.setAttribute("showCalc", "text", "DMG Calc ▲")
     Global.UI.setAttribute("showCalc", "textColor", "rgb(1, 1, 1)")
  else
     Global.UI.hide("calculator")
     shown.calculator = false
     Global.UI.setAttribute("showCalc", "text", "DMG Calc ▼")
     Global.UI.setAttribute("showCalc", "textColor", "rgb(1, 1, 1)")
  end
end

function statsClose(player, value, id)
  Global.UI.hide("stats")
  shown.stats = false
end

function toggleDice(player, value, id)
  -- Current color scheme is lit when false and dim when true
  -- It's easier to revert reported values than to update color scheme
  -- Also value initially is a goddamn string, not boolean
  value = (value == "False")
  log(id .. "=" .. tostring(value))

  setDice(id, value)
end

function getParamName(id)
  for k in pairs(paramRange) do
    if string.find(id, k, 1, true) then
      return k
    end
  end
end

function getParamChange(id)
  if string.find(id, "+", 1, true) then
    return 1;
  else
    return -1;
  end
end

function adjustParam(player, value, id)
  local name = getParamName(id)
  local delta = getParamChange(id)
  local min = paramRange[name].min
  local max = paramRange[name].max

  if delta < 0  and prm[name] > min then
    setParam(name, prm[name] - 1)
  elseif delta > 0 and prm[name] < max then
    setParam(name, prm[name] + 1)
  end

  log(name .. "=" .. prm[name])
end



function calculate(player, value, id)
  local dice = {}
  for _,v in pairs(diceCollection) do
    if v.state then table.insert(dice, v.die) end
  end

  if dice[1] == nil then
    broadcastToColor("Choose at least one die", player.color, stringColorToRGB(player.color))
    return
  end

  broadcastToAll(player.steam_name .. " calculates...", stringColorToRGB(player.color))

  -- caclulate number of cases for each outcome
  local state = {range=0, dmg=0, weight=1}
  result = {} --isn't local intentionally
  calcIteration(dice, 1, state, result)

  -- convert to percentage
  local totalCases = 6^#dice
  for k,v in pairs(result) do
    result[k] = result[k] * 100 / totalCases
  end

  -- add ammo consumption statistics
  -- red and yellow dice has chance of 1/3 to spend ammo each
  local ammoDices = 0
  if diceCollection.red.state then ammoDices = ammoDices + 1 end
  if diceCollection.yellow.state then ammoDices = ammoDices + 1 end
  result["ammo"] = (1 - (2/3)^ammoDices) * 100

  showStats()
end

-- caclulate number of cases for each outcome
function calcIteration(dice, depth, state, result)
  -- if reached the bottom, save results and exit
  if dice[depth] == nil then
    if prm.distance > (state.range + prm.accuracy) then
      result["miss"] = (result["miss"] or 0) + state.weight
    else
      local hit = math.floor((state.dmg + prm.deadly) / prm.armor)
      result[hit] = (result[hit] or 0) + state.weight
    end
    return
  end

  for i,v in ipairs(dice[depth]) do
    if v == "miss" then
      -- handle miss separately
      local diceLeft = #dice - depth
      local missWeight = state.weight * (6^diceLeft)
      result["miss"] = (result["miss"] or 0) + missWeight
    else
      -- go to the next depth
      local newState = {
        range = state.range + v.range,
        dmg = state.dmg + v.dmg,
        weight = state.weight * v.weight,
      }

      calcIteration(dice, depth+1, newState, result)
    end
  end
end

function showStats()
  --common stats
  Global.UI.setAttribute("ammoPb", "percentage", result["ammo"] or 0)
  Global.UI.setAttribute("missPb", "percentage", result["miss"] or 0)

  --specific stats
  if not cumulativeStatsMode then
    setExactStats()
  else
    setCumulativeStats()
  end

  Global.UI.show("stats")
  shown.stats = true
end


function setExactStats()
  for i = 0,15 do
    Global.UI.setAttribute(tostring(i) .. "t", "text", tostring(i) .. "dmg")
    Global.UI.setAttribute(tostring(i) .. "Pb", "percentage", result[i] or 0)
  end
end

function setCumulativeStats()
  local sum = 0
  -- even though there are only 15 bars to display, to get proper sum of chances we should
  -- iterate result from maxdmg+maxdeadly or more
  -- TODO: redefine all magic numbers through named variables
  for i=25,0,-1 do
    sum = sum + (result[i] or 0)
    Global.UI.setAttribute(tostring(i) .. "Pb", "percentage", sum)
    Global.UI.setAttribute(tostring(i) .. "t", "text", "≥" .. tostring(i) .. "dmg")
  end
end

function toggleStatsMode(player, value, id)
  cumulativeStatsMode = not cumulativeStatsMode
  showStats()
end


function rollWatch()
  for i,v in pairs(diceCollection) do
    if v.state and not v.dieObj.resting then
      return false
    end
  end
  return true
end

function addDieValue(sum, value)
  sum.range = sum.range + (value.range or 0)
  sum.dmg = sum.dmg + (value.dmg or 0)
  sum.ammo = sum.ammo or value.ammo
  sum.miss = sum.miss or value.miss
end

function rollEnd(player)
  -- print each dice individually and count sum
  log(" --- Roll end --- ")

  local currentRoll = {}
  local sum = {range=0, dmg=0, ammo=false, miss=false}
  for k,v in pairs(diceCollection) do
    if v.state then
      local value = getRotationValueTable(v.dieObj)
      log(value, k .." rolled by " .. player.color .. ": ")
      addDieValue(sum, value)
      currentRoll[k] = value
    else
      currentRoll[k] = nil
      if reroll and lastRoll[k] then
        -- die wasn't rolled now, but it's part of previous roll, which is rerolled
        addDieValue(sum, lastRoll[k])
        log(lastRoll[k], k .. " used from previous roll: " )
      end
    end
  end

  if not reroll then
    lastRoll = currentRoll
  end

  -- raw sum report
  local total = ""
  if sum.miss then
    total = total .. "MISS "
  end
  total = total .. tostring(sum.range) .. "range"
  if prm.accuracy ~= 0 then
    total = total .. "+" .. tostring(prm.accuracy)
  end

  total = total .. " " .. tostring(sum.dmg) .. "dmg"
  if prm.deadly ~= 0 then
    total = total .. "+" .. tostring(prm.deadly)
  end

  if sum.ammo then total = total .. " ammo" end
  broadcastToAll(total, stringColorToRGB(player.color))

  -- bonus/armor/distance accounted
  if sum.miss then
    broadcastToAll("MISS on dice", stringColorToRGB("Pink"))
  else
    if sum.range + prm.accuracy < prm.distance then
      broadcastToAll("MISS: Range + accuracy is too low", stringColorToRGB("Pink"))
    else
      local hit = math.floor((sum.dmg + prm.deadly) / prm.armor)
      if hit == 0 then
        broadcastToAll("HIT: no penetration", stringColorToRGB("Pink"))
      else
        broadcastToAll("HIT: " .. hit .. " wounds", stringColorToRGB("Pink"))
      end
    end
  end

  -- highlight ammo consumption in CAPS if not melee and not invader player
  if sum.ammo and player.color ~= "White" and prm.distance ~= 0 then
    broadcastToAll("AMMO LOST", stringColorToRGB("Pink"))
  end

  updateDiceFaces()

  -- This MUST be called, and also this should be the last thing to execute
  toggleInteraction(true)
end

function rollDice(player, value, id)
  local rollHappened = false
  for _,v in pairs(diceCollection) do
    if v.state then
      v.dieObj.roll()
      v.dieObj.highlightOn(Color.pink, 45)
      rollHappened = true
    else
      v.dieObj.highlightOff()
    end
  end

  if not rollHappened then return end
  --shut down controls, so nobody messes with parameters
  toggleInteraction(false)
  broadcastToAll(player.steam_name .. " rolls...", stringColorToRGB(player.color))

  Wait.condition(
    function() return rollEnd(player) end,
    rollWatch
  )
end

function getRotationValueTable(obj)
  local str = obj.getRotationValue()
  local rez = {}
  for k, v in string.gmatch(str, "(%w+)=?(%w*)") do
    if v == nil or v == "" then
      rez[k] = true
    else
      rez[k] = v
    end
  end
  return rez
end

function toggleInteraction(active)
  rollOngoing = not active
  Global.UI.setAttribute("distance-", "interactable", active)
  Global.UI.setAttribute("distance+", "interactable", active)

  Global.UI.setAttribute("armor-", "interactable", active)
  Global.UI.setAttribute("armor+", "interactable", active)

  Global.UI.setAttribute("accuracy-", "interactable", active)
  Global.UI.setAttribute("accuracy+", "interactable", active)

  Global.UI.setAttribute("deadly-", "interactable", active)
  Global.UI.setAttribute("deadly+", "interactable", active)

  Global.UI.setAttribute("red", "interactable", active)
  Global.UI.setAttribute("yellow", "interactable", active)
  Global.UI.setAttribute("green1", "interactable", active)
  Global.UI.setAttribute("green2", "interactable", active)
  Global.UI.setAttribute("blue1", "interactable", active)
  Global.UI.setAttribute("blue2", "interactable", active)

  Global.UI.setAttribute("rollDice", "interactable", active)
  Global.UI.setAttribute("rollDice", "textColor", "white")

  Global.UI.setAttribute("clearPrm", "interactable", active)
  Global.UI.setAttribute("clearPrm", "textColor", "white")

  Global.UI.setAttribute("reroll", "interactable", active)
end

-- return true if figure is 2 or more spaces width in direction of X and Z
function isLarge(figure)
  local bounds = figure.getBounds()
  return {
    x = (bounds.size.x > 1.5),
    z = (bounds.size.z > 1.5)
  }
end

function getDistance(first, second)

  local roundingDelta = {x = 0.5, z = 0.5}
  for _, figure in ipairs({first, second}) do
    local isLargeFigure = isLarge(figure)
    if isLargeFigure.x then
      roundingDelta.x = roundingDelta.x - 0.5
    end

    if isLargeFigure.z then
      roundingDelta.z = roundingDelta.z - 0.5
    end
  end

  local firstPos = first.getPosition()
  local secondPos = second.getPosition()

  local dx = math.floor(math.abs(secondPos.x - firstPos.x) + roundingDelta.x)
  local dz = math.floor(math.abs(secondPos.z - firstPos.z) + roundingDelta.z)

  return math.max(dx, dz)
end


function onScriptingButtonDown(index,  player_color)
  if index == 10 then
    -- set attacking figure
    if rollOngoing then
      broadcastToColor("Wait untill roll finishes",
        player_color,
        stringColorToRGB(player_color))
      return
    end

    saveAttackingCharacter(player_color)
  end

  if index == 1 then
    if rollOngoing then
      broadcastToColor("Wait untill roll finishes",
        player_color,
        stringColorToRGB(player_color))
      return
    end
    prepareAttackParameters(player_color)
  end


end

function getMonsterStats(name)
  for k,v in pairs(mnstStats) do
    if (string.find(name, k, 1, true)) then
      return v
    end
  end
end

function saveAttackingCharacter(player_color)
  -- set attacker, wait for target

  if attackingChar[player_color] then
    attackingChar[player_color].highlightOff()
    attackingChar[player_color] = nil
  end

  local candidate = Player[player_color].getHoverObject()
  if not candidate or not isCharacter(candidate) then
    broadcastToColor(
    "Hotkey is intended to mark figurine which is hovered over as attacker. " ..
    "Please hover over attacking character first.",
      player_color,
      stringColorToRGB(player_color))
    return
  end


  attackingChar[player_color] = candidate
  attackingChar[player_color].highlightOn(stringColorToRGB(player_color), 3600)
  printToColor("Attacker set to " .. attackingChar[player_color].getName(),
    player_color,
    stringColorToRGB(player_color))
end


function prepareAttackParameters(player_color)
  if not attackingChar[player_color] then
    if player_color == "White" then
      broadcastToColor(
        "You are trying to mark figurine hovered over as target, " ..
        "but you need to mark attacker first with Numpad0",
        player_color,
        stringColorToRGB(player_color))
      return
    else
      attackingChar[player_color] = getObjectFromGUID(marines[string.lower(player_color)])
      if not attackingChar[player_color] then
        broadcastToColor("Can't find your marine figure",
          player_color,
          stringColorToRGB(player_color))
        return
      end
    end
  end

  local target = Player[player_color].getHoverObject()
  if not target or not isCharacter(target) then
    broadcastToColor(
      "Hotkey is intended to mark figurine which is hovered over as target." ..
      "Please hover over targeted character first.",
      player_color,
      stringColorToRGB(player_color))
    return
  end

  printToAll("Params are set for " .. attackingChar[player_color].getName()
    .. " attacking " .. target.getName(),
    stringColorToRGB(player_color))


  local isMelee = false -- TODO: tricky thing for marines
                        -- probably can guess out of: last clicked weapon and single red die in play

  -- ATTACKER PARAMETERS: dice, accuracy and deadly bonuses
  --                      set for monster attacks only
  if isMonster(attackingChar[player_color]) then
    setDefaultParams()

    local stats = getMonsterStats(attackingChar[player_color].getName()) --guaranteed to exist
    for i,v in ipairs(stats.attack) do
      setDice(v, true)
    end

    for k,v in pairs(stats.attackMod) do
      if k ~= "melee" then
        setParam(k, v)
      end
    end

    if stats.attackMod and stats.attackMod.melee then
      isMelee = true
    end

    if stats.reminder and stats.reminder ~= "" then
      printToAll("Reminder: " .. stats.reminder, Color.Orange)
    end
  end

  -- TARGET PARAMETERS: distance and armor
  local armor = 1
  if isMonster(target) then
    armor = getMonsterStats(target.getName()).armor
  else
    armor = tonumber(target.UI.getAttribute("armor", "text"))
  end
  setParam("armor", armor)

  local dist = getDistance(attackingChar[player_color], target)
  if dist >= 15 then dist = 15 end

  if isMelee then
    dist = 0
  end
  setParam("distance", dist)

  -- indicate with highlight
  attackingChar[player_color].highlightOn(stringColorToRGB(player_color), 5)
  attackingChar[player_color] = nil
  target.highlightOn(stringColorToRGB(player_color), 5)

  if shown.calculator == false then
    showCalc()
  end
end

function updateDiceFaces()
  for k,v in pairs(diceCollection) do
    local clr = string.match(k, "(%a+)%d*")
    Global.UI.setAttribute(k.."Image", "image", clr .. " " .. v.dieObj.getRotationValue())
  end
end

function bringDiceBack()
  for k,v in pairs(diceCollection) do
    if v.dieObj.getPosition().y < -5 then
      broadcastToAll(k .. " die dropped off the table, returning...", stringColorToRGB("Pink"))
      v.dieObj.setPosition({-8.50, 13.00, 34.00})
      v.dieObj.setVelocity({0, 0, 0})
    end
  end
end

function refreshObjectUI()
  Wait.time(
    function()
      broadcastToAll("Refreshing object interfaces after new player connected", stringColorToRGB("Pink"))
      for _,v in ipairs(getAllObjects()) do
        local xml = v.UI.getXml()
        if xml and xml ~= "" then
          v.UI.setXml(xml)
        end
      end
    end,
    5)
end


function isSingleFigurine(obj)
  return obj.tag == "Figurine" and obj.getQuantity() == -1
end

function isMonster(obj)
  if not isSingleFigurine(obj) then
    return false
  end

  local name = obj.getName()
  for k,v in pairs(mnstStats) do
    if (string.find(name, k, 1, true)) then
      return true
    end
  end

  return false
end

function isMarine(obj)
  if not isSingleFigurine(obj) then
    return false
  end

  return (string.find(obj.getName(), "Marine", 1, true) ~= nil)
end

function isCharacter(obj)
  return isMonster(obj) or isMarine(obj)
end

function rerollToggle(player, value, id)
  reroll = (value == "True")
  log(id .. "=" .. tostring(reroll))

  if reroll then
    for k in pairs(diceCollection) do
      if not lastRoll[k] then
        Global.UI.setAttribute(k, "active", "false")
        setDice(k, false)
      end
    end
  else
    for k in pairs(diceCollection) do
      Global.UI.setAttribute(k, "active", "true")
    end
  end
end