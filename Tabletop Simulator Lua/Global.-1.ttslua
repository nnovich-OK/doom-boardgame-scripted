#include Console/console++

shown = {
  calculator = false,
  stats = false
}


function onload()
  -- assets sometimes load later than they are needed by objects
  -- so blank squares are shown instead of images for armor, speed etc
  -- workaround - refresh XML to redraw interfaces
  refreshObjectUI()
end


function onPlayerConnect(player)
  -- assets sometimes load later than they are needed by objects
  -- so blank squares are shown instead of images for armor, speed etc
  -- workaround - refresh UI for all objects
  -- needed to be done for each player individually
  refreshObjectUI()
end


function showCalc()
  if shown.calculator == false then
     Global.UI.show("calculator")
     shown.calculator = true
  else
     Global.UI.hide("calculator")
     shown.calculator = false
  end
end

function statsClose(player, value, id)
  Global.UI.hide("stats")
  shown.stats = false
end



-- return true if figure is 2 or more spaces width in direction of X and Z
function isLarge(figure)
  local bounds = figure.getBounds()
  return {
    x = (bounds.size.x > 1.5),
    z = (bounds.size.z > 1.5)
  }
end

function getDistance(first, second)

  local roundingDelta = {x = 0.5, z = 0.5}
  for _, figure in ipairs({first, second}) do
    local isLargeFigure = isLarge(figure)
    if isLargeFigure.x then
      roundingDelta.x = roundingDelta.x - 0.5
    end

    if isLargeFigure.z then
      roundingDelta.z = roundingDelta.z - 0.5
    end
  end

  local firstPos = first.getPosition()
  local secondPos = second.getPosition()

  local dx = math.floor(math.abs(secondPos.x - firstPos.x) + roundingDelta.x)
  local dz = math.floor(math.abs(secondPos.z - firstPos.z) + roundingDelta.z)

  return math.max(dx, dz)
end


function onScriptingButtonDown(index,  player_color)
  if index == 10 then
    -- set attacking figure
    if rollOngoing then
      broadcastToColor("Wait untill roll finishes",
        player_color,
        stringColorToRGB(player_color))
      return
    end

    saveAttackingCharacter(player_color)
  end

  if index == 1 then
    if rollOngoing then
      broadcastToColor("Wait untill roll finishes",
        player_color,
        stringColorToRGB(player_color))
      return
    end
    prepareAttackParameters(player_color)
  end
end

function getMonsterStats(name)
  for k,v in pairs(mnstStats) do
    if (string.find(name, k, 1, true)) then
      return v
    end
  end
end

function saveAttackingCharacter(player_color)
  -- set attacker, wait for target

  if attackingChar[player_color] then
    attackingChar[player_color].highlightOff()
    attackingChar[player_color] = nil
  end

  local candidate = Player[player_color].getHoverObject()
  if not candidate or not isCharacter(candidate) then
    broadcastToColor(
    "Hotkey is intended to mark figurine which is hovered over as attacker. " ..
    "Please hover over attacking character first.",
      player_color,
      stringColorToRGB(player_color))
    return
  end


  attackingChar[player_color] = candidate
  attackingChar[player_color].highlightOn(stringColorToRGB(player_color), 3600)
  printToColor("Attacker set to " .. attackingChar[player_color].getName(),
    player_color,
    stringColorToRGB(player_color))
end


function prepareAttackParameters(player_color)
  if not attackingChar[player_color] then
    if player_color == "White" then
      broadcastToColor(
        "You are trying to mark figurine hovered over as target, " ..
        "but you need to mark attacker first with Numpad0",
        player_color,
        stringColorToRGB(player_color))
      return
    else
      attackingChar[player_color] = getObjectFromGUID(marines[string.lower(player_color)])
      if not attackingChar[player_color] then
        broadcastToColor("Can't find your marine figure",
          player_color,
          stringColorToRGB(player_color))
        return
      end
    end
  end

  local target = Player[player_color].getHoverObject()
  if not target or not isCharacter(target) then
    broadcastToColor(
      "Hotkey is intended to mark figurine which is hovered over as target." ..
      "Please hover over targeted character first.",
      player_color,
      stringColorToRGB(player_color))
    return
  end

  printToAll("Params are set for " .. attackingChar[player_color].getName()
    .. " attacking " .. target.getName(),
    stringColorToRGB(player_color))


  local isMelee = false -- TODO: tricky thing for marines
                        -- probably can guess out of: last clicked weapon and single red die in play

  -- ATTACKER PARAMETERS: dice, accuracy and deadly bonuses
  --                      set for monster attacks only
  if isMonster(attackingChar[player_color]) then
    setDefaultParams()

    local stats = getMonsterStats(attackingChar[player_color].getName()) --guaranteed to exist
    for i,v in ipairs(stats.attack) do
      setDice(v, true)
    end

    for k,v in pairs(stats.attackMod) do
      if k ~= "melee" then
        setParam(k, v)
      end
    end

    if stats.attackMod and stats.attackMod.melee then
      isMelee = true
    end

    if stats.reminder and stats.reminder ~= "" then
      printToAll("Reminder: " .. stats.reminder, Color.Orange)
    end
  end

  -- TARGET PARAMETERS: distance and armor
  local armor = 1
  if isMonster(target) then
    armor = getMonsterStats(target.getName()).armor
  else
    armor = tonumber(target.UI.getAttribute("armor", "text"))
  end
  setParam("armor", armor)

  local dist = getDistance(attackingChar[player_color], target)
  if dist >= 15 then dist = 15 end

  if isMelee then
    dist = 0
  end
  setParam("distance", dist)

  -- indicate with highlight
  attackingChar[player_color].highlightOn(stringColorToRGB(player_color), 5)
  attackingChar[player_color] = nil
  target.highlightOn(stringColorToRGB(player_color), 5)

  if shown.calculator == false then
    showCalc()
  end
end

function refreshObjectUI()
  Wait.time(
    function()
      broadcastToAll("Refreshing object interfaces after new player connected", Color.Orange)
      for _,v in ipairs(getAllObjects()) do
        local xml = v.UI.getXml()
        if xml and xml ~= "" then
          v.UI.setXml(xml)
        end
      end
    end,
    5)
end


function isSingleFigurine(obj)
  return obj.tag == "Figurine" and obj.getQuantity() == -1
end

function isMonster(obj)
  if not isSingleFigurine(obj) then
    return false
  end

  local name = obj.getName()
  for k,v in pairs(mnstStats) do
    if (string.find(name, k, 1, true)) then
      return true
    end
  end

  return false
end

function isMarine(obj)
  if not isSingleFigurine(obj) then
    return false
  end

  return (string.find(obj.getName(), "Marine", 1, true) ~= nil)
end

function isCharacter(obj)
  return isMonster(obj) or isMarine(obj)
end
